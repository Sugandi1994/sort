<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Penghapus Latar Belakang (Background) Foto AI</title>
    <!-- Memuat Tailwind CSS untuk styling yang cepat dan responsif -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Gaya kustom untuk memastikan kanvas dan kontrol terlihat bagus */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7fafc;
        }
        #canvas-container {
            position: relative;
            /* Ukuran container utama untuk kanvas, responsif di mobile */
            max-width: 90vw;
            max-height: 70vh;
            margin: auto;
            border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            overflow: hidden; /* Penting agar kuas tidak keluar batas */
            background-color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #drawing-canvas, #display-canvas {
            cursor: crosshair;
            display: block;
            background-color: transparent;
        }
        /* Style untuk kuas penghapus */
        #brush-preview {
            position: absolute;
            pointer-events: none; /* Agar tidak menghalangi interaksi kanvas */
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            background-color: rgba(255, 0, 0, 0.5); /* Warna overlay saat menghapus */
            display: none; /* Sembunyikan secara default */
            z-index: 10;
        }
        .control-group {
            background-color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }
        /* Style untuk loading spinner */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="p-4 md:p-8 min-h-screen flex items-center justify-center">

    <div class="max-w-6xl mx-auto">
        <h1 class="text-3xl font-extrabold text-gray-900 mb-6 text-center">
            Penghapus Latar Belakang Foto (Manual & AI)
        </h1>

        <!-- Area Kontrol Atas -->
        <div class="control-group mb-6 flex flex-col lg:flex-row items-center justify-between gap-4 p-4">
            
            <!-- Group 1: File Upload & Save -->
            <div class="flex flex-wrap items-center gap-4">
                <!-- Input File -->
                <label for="imageUpload" class="cursor-pointer bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-200 shadow-md flex items-center">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                    1. Pilih Foto
                    <input type="file" id="imageUpload" accept="image/*" class="hidden" />
                </label>
            
                <!-- Tombol Simpan -->
                <button id="saveButton" disabled class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-200 shadow-md disabled:opacity-50 flex items-center">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                    Simpan PNG
                </button>
            </div>

            <!-- Group 2: AI Auto Removal -->
            <div class="flex items-center gap-4">
                 <!-- Tombol Hapus Otomatis AI -->
                <button id="aiRemoveButton" disabled class="bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-200 shadow-md disabled:opacity-50 flex items-center">
                    <span id="aiButtonText" class="flex items-center">
                        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9.75 10m0 0l-3-3m3 3h7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                        2. Hapus Otomatis (AI)
                    </span>
                    <div id="aiLoadingSpinner" class="spinner hidden ml-2"></div>
                </button>
            </div>

            <!-- Group 3: Manual Brush Controls -->
            <div class="flex items-center space-x-4 mt-4 lg:mt-0">
                <label for="brushSize" class="text-gray-700 font-medium whitespace-nowrap">3. Ukuran Kuas: <span id="brushSizeValue" class="font-bold text-indigo-600">50</span></label>
                <input type="range" id="brushSize" min="10" max="200" value="50" class="w-full md:w-40 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
            </div>

        </div>

        <!-- Kontainer Kanvas & Preview Kuas -->
        <div id="canvas-container" class="w-full h-96 bg-gray-200 border-dashed border-2 border-gray-400">
            <!-- Kanvas 1: Menampilkan Foto Asli & Hasil Masking (yang akan kita simpan) -->
            <canvas id="display-canvas" class="absolute top-0 left-0"></canvas>

            <!-- Kanvas 2: Untuk menggambar mask/area yang akan dihapus (Manual) -->
            <canvas id="drawing-canvas" class="absolute top-0 left-0"></canvas>

            <!-- Preview Kuas -->
            <div id="brush-preview"></div>

            <p id="infoMessage" class="text-gray-500 text-lg p-4">
                Pilih foto untuk memulai!
            </p>
        </div>

        <!-- Area Pesan (untuk error/informasi) -->
        <div id="statusMessage" class="mt-4 p-3 bg-yellow-100 text-yellow-800 rounded-lg hidden"></div>
    </div>

    <script>
        // Inisialisasi variabel global
        let image = null;
        let isDrawing = false;
        let brushSize = 50;
        let lastX = 0;
        let lastY = 0;
        let originalWidth = 0;
        let originalHeight = 0;
        let originalMimeType = ''; // Untuk menyimpan tipe file asli
        let originalBase64 = ''; // Untuk menyimpan Base64 asli tanpa prefix

        const API_KEY = ""; // Kunci API akan disediakan oleh lingkungan
        const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=" + API_KEY;

        // Mendapatkan elemen DOM
        const container = document.getElementById('canvas-container');
        const drawingCanvas = document.getElementById('drawing-canvas');
        const displayCanvas = document.getElementById('display-canvas');
        const imageUpload = document.getElementById('imageUpload');
        const brushSizeInput = document.getElementById('brushSize');
        const brushSizeValue = document.getElementById('brushSizeValue');
        const saveButton = document.getElementById('saveButton');
        const aiRemoveButton = document.getElementById('aiRemoveButton');
        const aiButtonText = document.getElementById('aiButtonText');
        const aiLoadingSpinner = document.getElementById('aiLoadingSpinner');
        const infoMessage = document.getElementById('infoMessage');
        const brushPreview = document.getElementById('brush-preview');
        const statusMessage = document.getElementById('statusMessage');

        // Mendapatkan konteks 2D untuk kanvas
        const drawingCtx = drawingCanvas.getContext('2d');
        const displayCtx = displayCanvas.getContext('2d');

        // --- FUNGSI UTILITY & UI ---

        function setLoadingState(isLoading) {
            aiRemoveButton.disabled = isLoading || !image;
            saveButton.disabled = isLoading || !image;
            brushSizeInput.disabled = isLoading;
            drawingCanvas.style.pointerEvents = isLoading ? 'none' : 'auto';
            
            if (isLoading) {
                aiButtonText.classList.add('hidden');
                aiLoadingSpinner.classList.remove('hidden');
                showStatus('Memproses gambar secara otomatis dengan AI. Mohon tunggu...', false);
            } else {
                aiButtonText.classList.remove('hidden');
                aiLoadingSpinner.classList.add('hidden');
            }
        }

        // Fungsi untuk menampilkan pesan status/error
        function showStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.className = `mt-4 p-3 rounded-lg ${isError ? 'bg-red-100 text-red-800' : 'bg-yellow-100 text-yellow-800'}`;
            statusMessage.style.display = 'block';
        }

        // Fungsi untuk menyembunyikan pesan status
        function hideStatus() {
            statusMessage.style.display = 'none';
        }

        // Fungsi yang dipanggil saat ukuran kanvas berubah (resize atau pemuatan gambar baru)
        function resizeCanvases() {
            if (!image) return;

            // Hitung rasio untuk menyesuaikan gambar ke container
            const containerW = container.clientWidth;
            const containerH = container.clientHeight;

            const ratioX = containerW / originalWidth;
            const ratioY = containerH / originalHeight;
            const ratio = Math.min(ratioX, ratioY);

            // Tentukan ukuran baru kanvas berdasarkan rasio yang paling kecil
            const newW = originalWidth * ratio;
            const newH = originalHeight * ratio;

            // Set ukuran fisik elemen kanvas
            drawingCanvas.style.width = displayCanvas.style.width = `${newW}px`;
            drawingCanvas.style.height = displayCanvas.style.height = `${newH}px`;

            // Set resolusi internal kanvas
            drawingCanvas.width = displayCanvas.width = newW;
            drawingCanvas.height = displayCanvas.height = newH;

            // Terapkan kembali gambar pada kanvas utama
            redrawDisplay();

            // Atur konteks gambar untuk kanvas masking
            drawingCtx.lineCap = 'round';
            drawingCtx.lineJoin = 'round';
            drawingCtx.globalCompositeOperation = 'destination-out'; // Mode penghapusan
        }

        // Fungsi untuk menggambar ulang kanvas tampilan utama
        function redrawDisplay() {
            if (!image) return;

            const w = displayCanvas.width;
            const h = displayCanvas.height;

            // 1. Gambar latar belakang kotak-kotak (transparansi)
            drawCheckerboard(displayCtx, w, h);

            // 2. Gambar foto (yang mungkin sudah transparan dari AI)
            displayCtx.drawImage(image, 0, 0, w, h);

            // 3. Terapkan masking dari drawingCanvas ke displayCanvas (memotong area yang dihapus)
            // Ini memungkinkan pengguna untuk menyempurnakan hasil AI secara manual
            displayCtx.save();
            displayCtx.globalCompositeOperation = 'destination-out';
            displayCtx.drawImage(drawingCanvas, 0, 0, w, h);
            displayCtx.restore();
        }

        // Fungsi untuk membuat latar belakang kotak-kotak transparan
        function drawCheckerboard(ctx, w, h) {
            const size = 15;
            const color1 = '#ccc';
            const color2 = '#ddd';

            ctx.clearRect(0, 0, w, h); // Hapus dulu

            for (let y = 0; y < h; y += size) {
                for (let x = 0; x < w; x += size) {
                    ctx.fillStyle = ((x / size) % 2 === (y / size) % 2) ? color1 : color2;
                    ctx.fillRect(x, y, size, size);
                }
            }
        }

        // --- PEMUATAN GAMBAR ---

        // Pemuatan Gambar
        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            originalMimeType = file.type;
            hideStatus();
            infoMessage.style.display = 'none';
            setLoadingState(false); // Enable buttons

            const reader = new FileReader();
            reader.onload = (event) => {
                const base64String = event.target.result;
                // Simpan Base64 data (tanpa prefix "data:image/...")
                originalBase64 = base64String.split(',')[1];

                image = new Image();
                image.onload = () => {
                    originalWidth = image.width;
                    originalHeight = image.height;

                    // Bersihkan kanvas masking (mask awal harus kosong/putih)
                    drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                    
                    resizeCanvases();
                    showStatus('Foto siap diedit. Pilih "Hapus Otomatis (AI)" atau gunakan kuas manual.', false);
                };
                image.onerror = () => {
                    showStatus('Gagal memuat gambar. Pastikan file adalah format gambar yang valid.', true);
                    image = null;
                    setLoadingState(false);
                };
                image.src = base64String;
            };
            reader.readAsDataURL(file);
        });

        // --- LOGIKA AI (GEMINI) ---

        aiRemoveButton.addEventListener('click', processImageWithAI);

        async function processImageWithAI() {
            if (!image || !originalBase64) {
                showStatus('Tidak ada gambar yang dimuat.', true);
                return;
            }

            setLoadingState(true);
            showStatus('Memulai penghapusan latar belakang otomatis oleh AI. Ini mungkin memakan waktu sebentar...', false);

            const userPrompt = "Hapus latar belakang dari gambar ini. Pastikan subjek utama dipertahankan sepenuhnya, dan latar belakang yang dihapus menjadi transparan. Kembalikan gambar hasil edit dalam format PNG.";
            
            const payload = {
                contents: [{
                    role: "user",
                    parts: [
                        { text: userPrompt },
                        {
                            inlineData: {
                                // Model lebih fleksibel jika mimeType spesifik
                                mimeType: originalMimeType || "image/jpeg", 
                                data: originalBase64 // Data Base64 tanpa prefix
                            }
                        }
                    ]
                }],
                generationConfig: {
                    responseModalities: ['TEXT', 'IMAGE']
                },
            };

            try {
                // Implementasi backoff eksponensial untuk retry
                const MAX_RETRIES = 3;
                let response = null;
                for (let i = 0; i < MAX_RETRIES; i++) {
                    response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status !== 429) break; // Berhasil atau error lain, keluar dari loop

                    // Retry: Tunggu dengan backoff eksponensial (1s, 2s, 4s, ...)
                    const delay = Math.pow(2, i) * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                    console.warn(`Retry API call ${i + 1}/${MAX_RETRIES} after throttling.`);
                }
                
                if (!response.ok) {
                    const errorJson = await response.json();
                    throw new Error(`HTTP Error: ${response.status} - ${errorJson.error?.message || 'Unknown API Error'}`);
                }

                const result = await response.json();
                const candidates = result?.candidates;

                if (!candidates || candidates.length === 0) {
                     // Jika tidak ada kandidat, cek apakah ada pesan error di level atas
                    const errorMessage = result?.error?.message || 'API mengembalikan respons kosong.';
                    throw new Error(`Pemrosesan AI gagal. API Error: ${errorMessage}`);
                }
                
                const candidate = candidates[0];
                const finishReason = candidate.finishReason;
                
                // Pengecekan baru: Jika alasan selesai bukan 'STOP', berarti ada pemblokiran atau kesalahan
                if (finishReason && finishReason !== 'STOP') {
                    let reasonMessage = `Proses AI diblokir karena alasan: ${finishReason}. `;
                    if (candidate.safetyRatings && candidate.safetyRatings.length > 0) {
                        reasonMessage += `Detail: ${candidate.safetyRatings.map(r => `${r.category}: ${r.probability}`).join(', ')}`;
                    }
                    console.error("Safety/Block Reason:", candidate.safetyRatings);
                    throw new Error(reasonMessage + 'Coba gunakan gambar lain.');
                }

                // Cari data gambar
                const base64Data = candidate.content?.parts?.find(p => p.inlineData)?.inlineData?.data;
                const textResponse = candidate.content?.parts?.find(p => p.text)?.text;

                if (!base64Data) {
                    // Jika data gambar tidak ada, cek apakah ada teks yang menjelaskan kegagalan
                    if (textResponse) {
                        throw new Error(`AI gagal menghasilkan gambar. Respon AI: ${textResponse}`);
                    }
                    // Error aslinya
                    throw new Error('AI gagal mengembalikan gambar yang diedit. Data gambar tidak ditemukan dalam respons.');
                }

                // Muat gambar hasil AI ke objek Image baru
                const newImageSrc = `data:image/png;base64,${base64Data}`;
                const newImage = new Image();
                newImage.onload = () => {
                    // 1. Ganti objek gambar global dengan hasil AI yang transparan
                    image = newImage;
                    originalWidth = image.width;
                    originalHeight = image.height;

                    // 2. Bersihkan semua mask manual sebelumnya, karena AI sudah menyediakan hasil akhir
                    drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                    
                    // 3. Tampilkan hasil
                    resizeCanvases(); 
                    showStatus('Penghapusan latar belakang otomatis selesai. Anda dapat menyimpan hasilnya atau menggunakan kuas manual untuk penyempurnaan.', false);
                    setLoadingState(false);
                };
                newImage.onerror = () => {
                    throw new Error('Gagal memuat gambar hasil AI. Data Base64 mungkin rusak.');
                };
                newImage.src = newImageSrc;

            } catch (error) {
                console.error("AI Processing Error:", error);
                showStatus(`Gagal memproses dengan AI: ${error.message}. Coba gunakan penghapus manual.`, true);
                setLoadingState(false);
            }
        }


        // --- LOGIKA MANUAL BRUSH (TETAP SAMA) ---

        // Update Ukuran Kuas
        brushSizeInput.addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value, 10);
            brushSizeValue.textContent = brushSize;
            brushPreview.style.width = brushPreview.style.height = `${brushSize}px`;
        });

        // Fungsi untuk mendapatkan koordinat relatif
        function getCanvasCoords(event) {
            const rect = drawingCanvas.getBoundingClientRect();
            let clientX, clientY;

            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            const x = clientX - rect.left;
            const y = clientY - rect.top;

            return { x, y };
        }

        // Mulai Menggambar
        function startDrawing(e) {
            e.preventDefault();
            if (!image || aiLoadingSpinner.classList.contains('hidden') === false) return; // Jangan gambar saat loading

            isDrawing = true;
            const coords = getCanvasCoords(e);
            lastX = coords.x;
            lastY = coords.y;

            draw(lastX, lastY);
        }

        // Menggambar
        function draw(x, y) {
            const scaleX = drawingCanvas.width / drawingCanvas.clientWidth;
            const scaleY = drawingCanvas.height / drawingCanvas.clientHeight;

            drawingCtx.lineWidth = brushSize * scaleX;

            drawingCtx.beginPath();
            drawingCtx.moveTo(lastX * scaleX, lastY * scaleY);
            drawingCtx.lineTo(x * scaleX, y * scaleY);
            drawingCtx.strokeStyle = 'red'; 
            drawingCtx.stroke();

            lastX = x;
            lastY = y;

            redrawDisplay();
        }

        // Selama Menggambar/Mouse Bergerak
        function whileDrawing(e) {
            e.preventDefault();
            const coords = getCanvasCoords(e);

            // Perbarui preview kuas
            brushPreview.style.left = `${coords.x - (brushSize / 2)}px`;
            brushPreview.style.top = `${coords.y - (brushSize / 2)}px`;

            if (!isDrawing) return;

            draw(coords.x, coords.y);
        }

        // Akhiri Menggambar
        function stopDrawing() {
            isDrawing = false;
        }

        // Mouse Enter/Leave (Tampilkan/Sembunyikan Kuas Preview)
        container.addEventListener('mouseenter', () => {
            if (image && aiLoadingSpinner.classList.contains('hidden')) {
                brushPreview.style.display = 'block';
                brushPreview.style.width = brushPreview.style.height = `${brushSize}px`;
            }
        });
        container.addEventListener('mouseleave', () => {
            brushPreview.style.display = 'none';
            stopDrawing();
        });

        // Event listener untuk Mouse
        drawingCanvas.addEventListener('mousedown', startDrawing);
        drawingCanvas.addEventListener('mousemove', whileDrawing);
        drawingCanvas.addEventListener('mouseup', stopDrawing);

        // Event listener untuk Touch
        drawingCanvas.addEventListener('touchstart', startDrawing);
        drawingCanvas.addEventListener('touchmove', whileDrawing);
        drawingCanvas.addEventListener('touchend', stopDrawing);


        // --- SIMPAN FILE PNG ---

        saveButton.addEventListener('click', () => {
            if (!image) {
                showStatus('Tidak ada gambar yang dimuat untuk disimpan.', true);
                return;
            }

            // 1. Buat kanvas resolusi penuh untuk menyimpan hasil
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = originalWidth;
            finalCanvas.height = originalHeight;
            const finalCtx = finalCanvas.getContext('2d');

            // 2. Gambar foto (hasil AI atau original) ke kanvas final
            finalCtx.drawImage(image, 0, 0, originalWidth, originalHeight);

            // 3. Terapkan mask manual (jika ada) ke kanvas final
            const tempMaskCanvas = document.createElement('canvas');
            tempMaskCanvas.width = originalWidth;
            tempMaskCanvas.height = originalHeight;
            const tempMaskCtx = tempMaskCanvas.getContext('2d');
            
            // Atur mask kanvas agar sesuai dengan apa yang digambar di drawingCanvas
            tempMaskCtx.drawImage(drawingCanvas, 0, 0, tempMaskCanvas.width, tempMaskCanvas.height);

            // Terapkan mask ke gambar
            finalCtx.globalCompositeOperation = 'destination-out';
            finalCtx.drawImage(tempMaskCanvas, 0, 0);

            // 4. Unduh file
            const dataURL = finalCanvas.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = 'foto-tanpa-background-ai-edit.png';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            showStatus('Gambar berhasil disimpan sebagai PNG transparan!', false);
        });


        // --- SETUP AWAL ---

        window.addEventListener('resize', resizeCanvases);
        brushPreview.style.width = brushPreview.style.height = `${brushSize}px`;

    </script>
</body>
</html>
